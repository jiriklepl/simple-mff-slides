%\documentclass{beamer}
% because the year is likely >2015, might want to support widescreen:
\documentclass[aspectratio=169]{beamer}
% (the default is 43, i.e. 4:3)


\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{xcolor}

\usepackage{tikz}\usetikzlibrary{positioning}
\usepackage{listings}
\usepackage{fontawesome5}

\usetheme{metropolis}

% Careful with the colors!
%\setbeamercolor{normal text}{fg=black!75,bg=black!2}
%\setbeamercolor{alerted text}{fg=green!80!black}
%\setbeamercolor{palette primary}{fg=red!10,bg=violet!50!black}
%\setbeamercolor{palette primary}{bg=red!40!black}
%\setbeamercolor{palette primary}{bg=green!50!yellow!80!black}

\usepackage{FiraSans}

\author{Jiří Klepl}
\title{Inference-driven resource managemenent and polymorphism in systems programming}
\date{MFF UK, September 2022}

\newcommand{\xxx}[1]{\textcolor{red!}{#1}}
\newcommand{\li}[1]{\lstinline{#1}}
\def\cmm{\texttt{C-\relax-}}
\def\smll{\scriptsize}

\begin{document}
\maketitle

\begin{frame}{High-level languages and systems programming}
\textbf{General motivating problem:}\\
Coding low-level systems in simple languages is laborous and error-prone.

\vspace{5ex}
\begin{columns}
\begin{column}{.5\linewidth}
Desirable language features:
\begin{itemize}\scriptsize
\item \textbf{Good generics} to prevent repetition
\item \textbf{Deep typechecking} to prevent errors
\item \textbf{Type inference} to reduce redundant annotations
\item \textbf{Readable syntax} to prevent obscurity
\item \textbf{Resource management} for runtime correctness
\item \textbf{No unnecessary overhead} to allow use with limited resources
\end{itemize}
\end{column}\pause
\begin{column}{.5\linewidth}
Language development examples:
  \begin{itemize}\scriptsize
  \item New features of C++
  \item Rust
  \item Nim, Clean, \dots
  \item Ivory (embedded in Haskell)
  \item C verified by Isabelle/HOL (SeL4 kernel)
  \end{itemize}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{Previously in a bachelor thesis: CHM}
\begin{columns}
\begin{column}{.5\linewidth}
  \begin{itemize}\small
  \item[\color{blue!66}\faArrowRight] ``C with type inference'' \\{\smll\dots based on \alert<3>{Hindley-Damas-Milner system}\par}
  \item[\color{blue!66}\faArrowRight] Overloading and generics \\ via typeclasses
  \item[\color{blue!66}\faArrowRight] Monomorphization \\{\smll(similar to C++ template instantiation)\par}
  \end{itemize}
\end{column}\pause
\begin{column}{.5\linewidth}
  \begin{itemize}\small
  \item[\color{red}\faTimes] Poor inference of \\ \texttt{struct} member access \\ {\smll(What is the type of \texttt{.some\_member} ?)\par}
  \item[\color{red}\faTimes] No support for resource management
  \item[\color{red}\faTimes] No subtypes \\{\smll (C \texttt{const}, implicit number conversions)\par}
  \item[\color{red}\faTimes] Not much extensibility \\{\smll(e.g. existentials for run-time polymorphism)\par}
  \item[\color{red}\faTimes] Code generation limited to C \\{\smll (No tail calls etc.)\par}
  \end{itemize}
\end{column}
\end{columns}

\vspace{3ex}
\pause\textbf{Idea for this thesis:} Try a \alert{better type system} and see what happens.
\end{frame}

% TODO sem mozna hod slajd ve kterym je ukazka nejakyho CHM kodu, pripadne neco na cem ukazes nejakej problem

\begin{frame}{Main results in this thesis}
  \begin{itemize}
  \item[\color{green!80!black}\faCheck] Substantial subset of \cmm{} (with tail calls!) + a compiler to LLVM
  \item[\color{green!80!black}\faCheck] Extremely capable constraint-solver-based type system
  \item Support for multiparameter typeclasses allows:
    \begin{itemize}
      \item[\color{green!80!black}\faCheck] modeling \texttt{struct} member access
      \item[\color{green!80!black}\faCheck] resource management via \texttt{Drop} typeclass
    \end{itemize}
  \item[\color{green!80!black}\faCheck] Extensible subtype system (\cmm{} constness and data `kinds')
  \end{itemize}
\end{frame}

% TODO sem hod slajd ve kterym sou 1-2 ukazky CHMMM kodu

% Start with roughly 3 slides that work as an `abstract'. Give a totally brief
% overview of what is the motivation for the thesis, how you approached it, and
% what is the main result.
%
% The point of this is that your problem, approach and results, if coherent,
% will deliver a message to the commitee that your thesis MAKES SENSE. The
% sooner they know, the better.
%
% I follow with a demonstration that shows how I would present and defend why I
% developed this `template' slideshow.

\begin{frame}{Goals}
  \begin{itemize}
    \item Reduction of code repetition in systems programming
    \item Type inference of variables and record fields
    \item Automatic resource management
    \item Tackling subtypes
      \begin{itemize}
        \item Many low-level languages have various \emph{constness} requirements (\li{constexpr}) on variables or some other requirements that are parallel to the types recognized by the languages
      \end{itemize}
  \end{itemize}
  
  \pause
  
  How do we achieve these goals?
  
  \pause
  
  \begin{itemize}
    \item Parametric polymorphism (idea: ``linear'' type functions)
    \item Multi-parameter typeclasses (overloading constrained by a relation)
    \item Automatic calls to resource management functions (bound to a resource lifetime)
    \item New extension to Hindley-Milner-style type systems
  \end{itemize}
\end{frame}

\begin{frame}{Proof-of-concept compiler}
  \begin{enumerate}
    \item Tokenization and parsing (\xxx{arrow} AST)
    \item Flow and variable live-range analysis (\xxx{arrow} annotated AST and \xxx{some metadata})
    \begin{itemize}
      \color{olive}
      \item Automatic resource management added to the AST
    \end{itemize}
    \item Constraint generation and AST elaboration
    \item Type inference
    \item Monomorphization and postprocessing of the elaborated AST according to the inferred types (name mangling, insertion of inferred types)
    \item Assembly generation
  \end{enumerate}
\end{frame}

\begin{frame}{\xxx{Focus: type inference}}
  \begin{itemize}
    \only<1,2>{\item Parametric polymorphism}
    \only<2> {
      \begin{itemize}
        \item Types: ${\color{magenta} \mathtt{bits32}}, {\color{orange} \alpha \to \beta}, {\color{purple} \forall a . a}$
        \vfill
        \item Type variables
        \begin{itemize}
          \item Free (unbound): $\forall a . a \to {\color{magenta} \alpha}$
          
          {\color{gray} can be later \emph{substituted} with a different type}
          \item Bound: $\forall {\color{magenta} a} . {\color{magenta} a} \to {\color{magenta} a}$ (\texttt{id} function)
          
          {\color{gray} can be instantiated into multiple types according to the given context}
        \end{itemize}
        \item Type constructors
        \begin{itemize}
          \item Functions: $\tau\ {\color{magenta} \to}\ \sigma$
          \item Type constants: ${\color{magenta} \mathtt{bits32}}, {\color{orange} \mathtt{bool}}$
          \item Product types, sum types, and their combination
        \end{itemize}
      \end{itemize}
    }
    \only<1,3>{\item Multi-parameter typeclasses: overloading constrained by a relation}
    \only<3>{
      \begin{itemize}
        \item Multi-parameter typeclass: a relation over some types (represented by type variables)
        
        \li{class Name a b c}: a type class over types $a, b, c$

        \li{instance Name bits32 bits32 bits64}: a type class instance given by $[a := \mathtt{bits32}, b := \mathtt{bits32}, c := \mathtt{bits64}]$

        \vfill

        \item Typeclass method: a function defined under the given typeclass, their type defined via the type variables of the enclosing typeclass
        
        \li{m :: (a, b) -> c}: a method with the argument $(a, b)$ returning $c$

        The \li{instance Name bits32 bits32 bits64} instance then contains the definition of the instance of $\mathtt{m}$ with the typing $(\mathtt{bits32}, \mathtt{bits32}) \to \mathtt{bits64}$

        \vfill
        \item Functional dependencies: \li{class Name a b c | a b -> c} - specifies that, for any instance, each pair $a, b$ uniquely determines $c$ (we can deduce it)
      \end{itemize}
    }
    \only<1,4>{\item Automatic calls to resource management functions (bound to a resource lifetime) }
    \only<4>{
      \begin{itemize}
        \item Closely related to the language's semantics, here we assume C-{}-: a scope is defined by a function activation (from the function entry to one of the corresponding exits); as customary, we tie a resource liverange to a scope
        \item Resource management actions performed by the user-definable \li{drop} functions

        \begin{itemize}
          \item usually overloaded in a \li{Drop} class so that every object issues a different action
        \end{itemize}

        \item resource-representing objects defined in \li{stackdata \{ ... \}} blocks
        
        \li{new Name: someType;} \hfill this defines a pointer \li{Name} to a stack-allocated object of \li{someType}

        \vfill
        \item Automatically inserted calls to the \li{drop} function at function exits (\li{return}s)
        \begin{itemize}
          \item Unless such exit follows a \li{dropped} statement that takes the name of the resource object
          \item In C++, for example, scopes with multiple exit points are the minority
        \end{itemize}
      \end{itemize}
    }
    \only<1,5>{\item New subtype extension to Hindley-Milner-style type systems }
    \only<5>{
      \begin{itemize}
        \item Many systems programming languages have subtypes (\li{const}, \li{constexpr}, etc.)
        \item In the extended C-{}-: \emph{kinds} and \emph{costnesses}
        \item Kind: a set of registers a value can be stored on
        \item Constness: specifies when the value is to be computed
        \begin{itemize}
          \item compile-time
          \item link-time
          \item run-time
        \end{itemize}
        \item Each HM-style type is extended with a kind dimension and a constness dimension
        \item Type (in-)nequalities can be specific to a dimension
        \item Different types can have a defined inequality relation in each dimension and yet be incomparable
        \item \xxx{probly next slide: jaky tam byly problemy - jaky sou limity takovyho navrhu, co nejde, co jde}
      \end{itemize}
    }
  \end{itemize}
\end{frame}

\begin{frame}[standout]{Je to na githubu + vyzkouset}
  \url{https://github.com/jiriklepl/masters-thesis-code}
\end{frame}


\begin{frame}{Difference between C-{}- and C}
  \begin{itemize}
    \item C-{}- can showcase more advanced control-flow primitives
    \begin{itemize}
      \item Explicit tail-calls: \li{jump} statements, in contrast to \li{call} statements
    \end{itemize}
    \item C-{}- has a simpler syntax
  \end{itemize}
\end{frame}

\begin{frame}{proc to je slozity}
\end{frame}

\begin{frame}{detaily implementace (asi 4 slajdy)}
\end{frame}

% if your approach idea can be made this simple, use a standout slide
\begin{frame}[standout]{Main approach idea}
Make example slides
$\to$
Put them on GitHub
\end{frame}

\begin{frame}{Results so far}
The impact is not known, because I am uploading the slides today.

\pause
From the availabe data (from other similar efforts), we can assume that:
\begin{itemize}
% some extra beamer magic
\item \alert<2>{More than 1 student will download and use the template}
\item \alert<3>{More than 5 minutes of time will be saved.} \uncover<3>{Likely more.}
\end{itemize}
\end{frame}

\begin{frame}{Demo: TikZ diagram}
\centering
\tikzstyle{rec}=[rectangle, draw, rounded corners=1ex, font=\huge\bfseries]
\begin{tikzpicture}[ultra thick, inner sep=1ex]
\node[rec] (a) {Keep};
\node[rec, circle, right=of a] (b) {it};
\node[rec, right=of b] (c) {simple};
\node[rec, densely dotted, below=2cm of c, font=\small] (notice) {\dots{}but precise!};
\draw[->] (a) to (b);
\draw[->] (b) to (c);
\draw[dotted] (notice) to (c);
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Demo: including formatted source}
% the fragile modifier (above) may be needed with many kinds of verbatim
% environments, also with lstlistings etc.

\begin{lstlisting}[language=C,showstringspaces=false,basicstyle=\tt\small,commentstyle=\color{green!50!black},keywordstyle=\bfseries\color{blue!50!black},stringstyle=\color{red!50!black}]
int main() {
  printf("The answer is: %d\n", 6*7); //actually 6*9
  return 0; //no chance this didn't succeed
}
\end{lstlisting}
\end{frame}

\begin{frame}{Demo: showing a picture with detailed results}
\centering
\includegraphics[height=0.8\textheight]{img/ukazka-obr01.pdf}
\end{frame}

\begin{frame}{Demo: showing something with comments}
\begin{columns}
\begin{column}{0.5\textwidth}
\includegraphics[width=\linewidth]{img/ukazka-obr01.pdf}
\end{column}
\begin{column}{0.5\textwidth}
How we arrived at this?
\begin{enumerate}
\item Generated the data
\item Plotted them
\item Used a very fine red marker to circle the points
\end{enumerate}

`Advantages' demo:

\begin{itemize}
\item[\color{green}\faCheck] Data is normal
\item[\color{red}\faTimes] Data is sparse
\item[\color{violet}\faQuestionCircle] What now?
\end{itemize}
\end{column}
\end{columns}
\end{frame}

% Ending frame is important -- in the rare case that you actually manage to
% finish the presentation on time, it avoids the embarassing seconds of silence
% between the time when you finish and the moment when committee detects that
% something is wrong and they should continue.
\begin{frame}[plain]
\centering
{\Large\bfseries Thank you for attention!}

% You can try the results on GitHub: \\
% \url{https://github.com/exaexa/simple-mff-slides}

\end{frame}
\end{document}

%\documentclass{beamer}
% because the year is likely >2015, might want to support widescreen:
\documentclass[aspectratio=169]{beamer}
% (the default is 43, i.e. 4:3)


\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{xcolor}

\usepackage{tikz}\usetikzlibrary{positioning}
\usepackage{listings}
\usepackage{fontawesome}

\usetheme{metropolis}

% Careful with the colors!
%\setbeamercolor{normal text}{fg=black!75,bg=black!2}
%\setbeamercolor{alerted text}{fg=green!80!black}
%\setbeamercolor{palette primary}{fg=red!10,bg=violet!50!black}
%\setbeamercolor{palette primary}{bg=red!40!black}
%\setbeamercolor{palette primary}{bg=green!50!yellow!80!black}

\usepackage{FiraSans}

\author{Jiří Klepl}
\title{Inference-driven resource managemenent and polymorphism in systems programming}
\date{MFF UK, September 2022}

\newcommand{\xxx}[1]{\textcolor{red!}{#1}}
\newcommand{\li}[1]{\lstinline{#1}}
\def\cmm{\texttt{C-\relax-}}
\def\smll{\scriptsize}

\begin{document}
\maketitle

\section{Introduction}

\begin{frame}{High-level languages and systems programming}
\textbf{General motivating problem:}\\
Coding low-level systems in simple languages is laborous and error-prone.

\vspace{5ex}
\begin{columns}
\begin{column}{.5\linewidth}
Desirable language features:
\begin{itemize}\scriptsize
\item \textbf{Good generics} to prevent repetition
\item \textbf{Deep typechecking} to prevent errors
\item \textbf{Type inference} to reduce redundant annotations
\item \textbf{Readable syntax} to prevent obscurity
\item \textbf{Resource management} for runtime correctness
\item \textbf{No unnecessary overhead} to allow use with limited resources
\end{itemize}
\end{column}\pause
\begin{column}{.5\linewidth}
Language development examples:
  \begin{itemize}\scriptsize
  \item New features of C++
  \item Rust, Nim, D, Swift, \dots
  \item Ivory (embedded in Haskell)
  \item C verified by Isabelle/HOL (SeL4 kernel)
  \end{itemize}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{Previously in a bachelor thesis: CHM}
\begin{columns}
\begin{column}{.5\linewidth}
  \begin{itemize}\small
  \item[\color{blue!66}\faArrowRight] ``C with type inference'' \\{\smll\dots based on \alert<3>{Hindley-Damas-Milner system}\par}
  \item[\color{blue!66}\faArrowRight] Overloading and generics \\ via typeclasses
  \item[\color{blue!66}\faArrowRight] Monomorphization \\{\smll(similar to C++ template instantiation)\par}
  \end{itemize}
\end{column}\pause%
\begin{column}{.5\linewidth}
  \begin{itemize}\small
  \item[\color{red}\faTimes] Poor inference of \\ \texttt{struct} member access \\ {\smll(What is the type of \li{.some\_member} ?)\par}
  \item[\color{red}\faTimes] No support for resource management \\{\smll(e.g. locks have to be unlocked, files closed)\par}
  \item[\color{red}\faTimes] No subtypes \\{\smll (C \li{const}, implicit number conversions)\par}
  \item[\color{red}\faTimes] Not much extensibility \\{\smll(e.g. existentials for run-time polymorphism)\par}
  \item[\color{red}\faTimes] Code generation limited to C 
  \end{itemize}
\end{column}
\end{columns}

\vspace{3ex}
\pause\textbf{Idea for this thesis:} Try a \alert{better type system} and see what happens.
\end{frame}

\begin{frame}[fragile]{CHM record fields}
\begin{columns}
  \begin{column}{.5\linewidth}
    \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
/* CHM required explicit type
   variable declarations like C++
*/
<a>
void access(a *s) {
  // what type is this:
  s->field;
}
    \end{lstlisting}
  \end{column}%
  \begin{column}{.5\linewidth}
    CHM (previous work) solution:
    \begin{itemize}\small
      \item All fields of the same name have to share the same type:

      
      \lstinline|struct A { int field; };|\\
      \lstinline|struct B { ... field; };|

      The type in \li{B} required to be \li{int} too

      \item[\color{red}\faTimes] Field types are still not inferred
      \item Field access is $\mathtt{struct} \to \mathtt{field}$
      \item We want to overload in both types, and for a given \li{struct}, we want the \li{field} type be unique
      
      \faArrowRight~ multi-parameter typeclasses with functional dependencies (MPTCs)
    \end{itemize}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}{Main results in this thesis}
  \begin{itemize}
  \item[\color{green!80!black}\faCheck] Substantial subset of \cmm{} and LLVM assembly output
  \item[\color{green!80!black}\faCheck] Reduction of code repetition via generics
  \item[\color{green!80!black}\faCheck] Capable constraint-solver-based type system
  \item Support for multiparameter typeclasses allows:
    \begin{itemize}
      \item[\color{green!80!black}\faCheck] Modeling \li{struct} member access
      \item[\color{green!80!black}\faCheck] Resource management via \li{Drop} typeclass, which defines the \li{drop} function
    \end{itemize}
  \item[\color{green!80!black}\faCheck] Extensible subtype system (\cmm{} constness and data `kinds')
  \end{itemize}
\end{frame}

\begin{frame}
  \centering
  An example of using generics:
  \begin{columns}
    \begin{column}{.5\linewidth}\small
    \end{column}%
    \begin{column}{.5\linewidth}\small
    \end{column}
  \end{columns}
\end{frame}

% TODO sem hod slajd ve kterym sou 1-2 ukazky CHMMM kodu

\begin{frame}{Difference between \cmm{} and \texttt{C}}
  \begin{itemize}
    \item Non-extended \cmm{} has very primitive type system
    \begin{itemize}
      \item However, with subtypes that affect register allocation and `constness' of variables
    \end{itemize} 
    \item \cmm{} contains advanced control-flow primitives
    \begin{itemize}
      \item Explicit tail-calls: \li{jump} statements, contrasting \li{call} statements
      \item Interprocedural equivalents to \li{goto} statements: \li{cut to} statements
    \end{itemize}
    \item \cmm{} has a simpler structure, for example:
    \begin{itemize}
      \item No \li{while} and \li{for} loops
      \item The whole function is one scope, variable declarations hoisted
      \item Expressions have no side-effects
    \end{itemize}
    \item \cmm{} allows for various alignment and aliasing assertions
  \end{itemize}
\end{frame}

% Start with roughly 3 slides that work as an `abstract'. Give a totally brief
% overview of what is the motivation for the thesis, how you approached it, and
% what is the main result.
%
% The point of this is that your problem, approach and results, if coherent,
% will deliver a message to the commitee that your thesis MAKES SENSE. The
% sooner they know, the better.
%
% I follow with a demonstration that shows how I would present and defend why I
% developed this `template' slideshow.

\section{Compiler}

\tikzstyle{bx}=[rectangle,draw,rounded corners=1ex,rotate=40]
\tikzstyle{wv}=[out=-30, in=130, ->]
\begin{frame}{Proof-of-concept compiler}
\centering
\begin{tikzpicture}[ultra thick, node distance=6em]
\node[bx,color=orange!80!gray] (p) {Tokenize and parse};
\node[bx,right=of p.center,anchor=center] (a) {Analyze flow};
\node[bx,right=of a.center,anchor=center] (e) {Constraints \& elaborated AST};
\node[bx,above=of e.center,xshift=2em,anchor=center,color=green!50!gray] (i) {Solve constraints};
\node[bx,right=10em of i.center,anchor=center,color=red!50] (r) {Report errors};
\node[bx,right=of e.center,anchor=center,color=green!50!gray] (m) {Monomorphize};
\node[bx,right=of m.center,anchor=center,color=cyan!80!gray] (l) {Generate LLVM};
\draw[->,out=0,in=130] ([xshift=-6em] p.center) to (p);
\draw[wv] (p) to (a);
\draw[wv] (a) to (e);
\draw[wv] (e) to (m);
\draw[->,out=100,in=-90] (e) to (i);
\draw[<->,out=-45,in=90,color=green!50!gray] (i) to (m.north east);
\draw[->,out=0,in=130,color=red!50] (i.south east) to (r);
\draw[wv] (m) to (l);
\draw[->,out=-30,in=180] (l) to ([xshift=6em] l.center);
\end{tikzpicture}

Compiler implemented in Haskell, uses \texttt{\color{cyan!80!gray}llvm-hs-pure} and \texttt{\color{orange!80!gray}megaparsec}; \textcolor{green!50!gray}{constraint-based type inference} is implemented natively.
\end{frame}

\begin{frame}{Tokenization and parsing}
  \begin{itemize}
    \item Use the \texttt{\color{orange!80!gray}megaparsec} library
    \item Generate the AST extending the \cmm{} language syntax specification from:
    
    \url{https://www.cs.tufts.edu/~nr/c--/extern/man2.pdf}

    In-code documentation clearly indicates all deviations from the standard so the implementation could be used for pure \cmm{}
  \end{itemize}
\end{frame}

\begin{frame}{Flow analysis -- ``Flattening'' and ``Blockifying''}
  \begin{itemize}
    \item Splitting into basic-blocks -- to facilitate flow analysis and LLVM generation
    \item Generation of the control-flow graph for each function
    \item Analysis of variable live-ranges inside the functions
    \item Insertion of resource management calls to the \li{drop} function (similar to use of destructors)
  \end{itemize}
\end{frame}

\begin{frame}{Constraint generation and AST elaboration}
  \begin{itemize}
    \item[\faSignIn] Input: the AST of the code
    \vfill
    \item[\faSignOut] Output
    \begin{itemize}
      \item List of constraints to be solved
      \item The elaborated AST
    \end{itemize}

    \item The constraints capture the desired type semantics of the code
    \item Example (simplified):
    
    $$x = a + b;$$
    
    \begin{itemize}
      \item $x : \alpha;\ a : \beta;\ b : \gamma;\ a + b : \delta;$ \hfill AST elaborations
      \item $\texttt{Num}\ \delta$ \hfill the result belongs to the \texttt{Num} typeclass (which defines (+))
      \item $\beta \sim \delta; \gamma \sim \delta$ \hfill arguments have the type of the result
      \item $\alpha \sim \delta$ \hfill the assignee and the result share the type
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Constraint solving}
  \begin{itemize}
    \item[\faSignIn] Input: list of constraints the types have to satisfy
    
    For example:
    \begin{itemize}
      \item Equality constraint $\tau_1 \sim \tau_2$ \hfill types $\tau_1, \tau_2$ have to be the same
      \item Class constraint $C \tau$ \hfill the type $\tau$ has to belong to the typeclass $C$ 
    \end{itemize} 
    \item[\faSignOut] Output: assignments of type variables to concrete types, leftover constraints
    \item We can combine the constraints $C_1, C_2$ (conjunction) $$C_1, C_2$$
    \item And nest the constraint $C$ while binding certain type variables $a, b$ and providing local assumptions $A$ $$\forall a, b . A \Rightarrow C$$
  \end{itemize}
\end{frame}

\begin{frame}{Monomorphization}
  \begin{itemize}
    \item[\faSignIn] Input: AST elaborated with the inferred (poly-)types
    \item[\faSignOut] Output: monomorphized AST elaborated with monotypes
    \item {\color{green!80!black} Mono}morphization = replacing {\color{orange} poly}morphic definitions with copies with the intended {\color{green!80!black} mono}types
  \end{itemize}
\end{frame}

\begin{frame}{LLVM generation}
  \begin{itemize}
    \item[\faSignIn] Input: monomorphized AST
    \begin{itemize}
      \item Elaborated with monotypes
      \item Elaborated with basic-block structure
      \item Control-flow and variable liveranges in relation to basic-blocks
    \end{itemize} 
    \item[\faSignOut] Output: the LLVM assembly
    \item Regular variables translated into LLVM registers
    \item Each local stack-object \li{alloca}'ted at function entry
    \item Translating each basic block separately
    \begin{itemize}
      \item[\only<1,3>{\faChevronRight}\only<2>{\faChevronDown}] Variables assigned-to by other basic blocks (or itself) imported via \underline{$\phi$-nodes}
      \only<2>{
        \begin{itemize}
          \item Located at the basic block entry
          \item For each variable that has to be {\color{green!80!black} alive}
          \item Each $\phi$-node takes all the possible values of the imported variables
          \item The values accompanied with the corresponding exporting basic-block labels
        \end{itemize}
      }
      \item[\only<1,2>{\faChevronRight}\only<3>{\faChevronDown}] Mapping variables to the current values while translating the inner statements
      \only<3>{
        \begin{itemize}
          \item Each statement can change this mapping
          \item This mapping then taken as the basic block's export
        \end{itemize}
      }
    \end{itemize}
  \end{itemize}
\end{frame}

\section{Details about the type system}

\begin{frame}{Type system details}
  \begin{itemize}
    \only<1,2>{\item[\color{cyan}\only<1>{\faChevronRight}\only<2>{\faChevronDown}] Parametric polymorphism with definable type constructors}
    \only<2> {
      \begin{itemize}
        \item Types: ${\color{magenta} \mathtt{bits32}}, {\color{orange} \alpha \to \beta}, {\color{purple} \forall a . a}$
        \vfill
        \item Type variables
        \begin{itemize}
          \item Free (unbound): $\forall a . a \to {\color{magenta} \alpha}$
          
          {\color{gray} can be later \emph{substituted} with a different type}
          \item Bound: $\forall {\color{magenta} a} . {\color{magenta} a} \to {\color{magenta} a}$ (\texttt{id} function)
          
          {\color{gray} can be instantiated into multiple types according to the given context}
        \end{itemize}
        \item Type constructors
        \begin{itemize}
          \item Functions: $\tau\ {\color{magenta} \to}\ \sigma$
          \item Type constants: ${\color{magenta} \mathtt{bits32}}, {\color{orange} \mathtt{bool}}$
          \item Product types, sum types, and their combination
          \item \li{struct} definitions
        \end{itemize}
      \end{itemize}
    }
    \only<1,3>{\item[\color{green!80!black}\only<1>{\faChevronRight}\only<3>{\faChevronDown}] Multi-parameter typeclasses: overloading constrained by a relation}
    \only<3>{
      \begin{itemize}
        \item Multi-parameter typeclass: a relation over some types (represented by type variables)
        
        \li{class Name a b c}: a type class over types $a, b, c$

        \li{instance Name bits32 bits32 bits64}: a type class instance given by $[a := \mathtt{bits32}, b := \mathtt{bits32}, c := \mathtt{bits64}]$

        \vfill

        \item Typeclass method: a function defined under the given typeclass, their type defined via the type variables of the enclosing typeclass
        
        \li{m :: (a, b) -> c}: a method with the argument $(a, b)$ returning $c$

        The \li{instance Name bits32 bits32 bits64} instance then contains the definition of the instance of $\mathtt{m}$ with the typing $(\mathtt{bits32}, \mathtt{bits32}) \to \mathtt{bits64}$

        \vfill
        \item Functional dependencies: \li{class Name a b c | a b -> c} - specifies that, for any instance, each pair $a, b$ uniquely determines $c$ (we can deduce it)
      \end{itemize}
    }
    \only<1,4>{\item[\color{orange}\only<1>{\faChevronRight}\only<4>{\faChevronDown}] Automatic calls to resource management functions (bound to a resource lifetime) }
    \only<4>{
      \begin{itemize}
        \item Closely related to the language's semantics, here we assume \cmm{}: a scope is defined by a function activation (from the function entry to one of the corresponding exits); as customary, we tie a resource liverange to a scope
        \item Resource management actions performed by the user-definable \li{drop} functions

        \begin{itemize}
          \item usually overloaded in a \li{Drop} class so that every object issues a different action
        \end{itemize}

        \item resource-representing objects defined in \li{stackdata \{ ... \}} blocks
        
        \li{new Name: someType;} \hfill this defines a pointer \li{Name} to a stack-allocated object of \li{someType}

        \vfill
        \item Automatically inserted calls to the \li{drop} function at function exits (\li{return}s)
        \begin{itemize}
          \item Unless such exit follows a \li{dropped} statement that takes the name of the resource object
          \item In C++, for example, scopes with multiple exit points are the minority
        \end{itemize}
      \end{itemize}
    }
    \only<1,5>{\item[\color{purple!75!white}\only<1>{\faChevronRight}\only<5>{\faChevronDown}] New subtype extension to Hindley-Milner-style type systems }
    \only<5>{
      \begin{itemize}
        \item Many systems programming languages have subtypes (\li{const}, \li{constexpr}, etc.)
        \item In the extended \cmm{}: \emph{kinds} and \emph{costnesses}
        \item Kind: a set of registers a value can be stored on
        \item Constness: specifies when the value is to be computed

        compile-time, link-time, run-time
        \item Each HM-style type is extended with a kind dimension and a constness dimension
        \item Type (in-)nequalities can be specific to a dimension
        
        \xxx{obrazek}
        \item Different types can have a defined inequality relation in each dimension and yet be incomparable
        \item \xxx{probly next slide: jaky tam byly problemy - jaky sou limity takovyho navrhu, co nejde, co jde}
      \end{itemize}
    }
  \end{itemize}
\end{frame}

% Ending frame is important -- in the rare case that you actually manage to
% finish the presentation on time, it avoids the embarassing seconds of silence
% between the time when you finish and the moment when committee detects that
% something is wrong and they should continue.
\begin{frame}[plain]
\centering
{\Large\bfseries Thank you for attention!}

You can try the results on GitHub: \\
\url{https://github.com/jiriklepl/masters-thesis-code}


\end{frame}

\section{Questions}

\begin{frame}{Backwards-compatibility and extensibility of other languages' type systems}
  \begin{itemize}
    \item The extended \cmm{} is not fully backwards-compatible with \cmm{} as it uses stronger type system
    \begin{itemize}
      \item Compiling \cmm{} programs would be possible with adding some type coercions
      \item \cmm{} programs are not meant to be portable between implementations anyway
    \end{itemize}
    \item The type system as explained in the thesis does not fit dynamic languages like Python, JavaScript or Julia without significantly restricting such languages
    \begin{itemize}
      \item Extending the type system with existentials as discussed in the thesis would make modelling such languages easier -- however, still not complete
    \end{itemize}
    \item The type system could be modified to fit the needs of a Rust-like language
    \begin{itemize}
      \item Successful implementation of Rust borrowing through type system would require the type system to be flow-sensitive
    \end{itemize}
  \end{itemize}
\end{frame}

\end{document}
